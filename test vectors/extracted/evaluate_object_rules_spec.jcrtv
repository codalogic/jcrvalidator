#-- Copyright (C) 2016 American Registry for Internet Numbers (ARIN)
#--
#-- Permission to use, copy, modify, and/or distribute this software for any
#-- purpose with or without fee is hereby granted, provided that the above
#-- copyright notice and this permission notice appear in all copies.
#--
#-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
#-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
#-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
#-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
#-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
#-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
#-- IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#-- Line: 20
#--     tree = JCR.parse( 'trule { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], 2, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail something that is not an object
JCR: Pass
    trule { }
JSON: Fail
     2

#-- Line: 28
#--     tree = JCR.parse( 'trule @(reject) { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], 2, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass something that is not an object with reject
JCR: Pass
    trule @(reject) { }
JSON: Pass
     2

#-- Line: 36
#--     tree = JCR.parse( 'trule { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an empty object against an empty object rule
JCR: Pass
    trule { }
JSON: Pass
     { }

#-- Line: 44
#--     tree = JCR.parse( 'trule @(reject) { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty object against an empty reject object rule
JCR: Pass
    trule @(reject) { }
JSON: Fail
     { }

#-- Line: 52
#--     tree = JCR.parse( 'trule { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"bar"}, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail a non-empty object against an empty object rule
JCR: Pass
    trule { }
JSON: Fail
     { "foo":"bar"}

#-- Line: 60
#--     tree = JCR.parse( 'trule @(reject) { }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"bar"}, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass a non-empty object against an empty reject object rule
JCR: Pass
    trule @(reject) { }
JSON: Pass
     { "foo":"bar"}

#-- Line: 68
#--     tree = JCR.parse( 'trule { "foo" :string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty object against an object rule with a string member
JCR: Pass
    trule { "foo" :string }
JSON: Fail
     { }

#-- Line: 76
#--     tree = JCR.parse( 'trule { "foo" :string, "bar" :string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty object against an object rule with a string member and a string member
JCR: Pass
    trule { "foo" :string, "bar" :string }
JSON: Fail
     { }

#-- Line: 84
#--     tree = JCR.parse( 'trule { "foo" :string| "bar" :string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty object against an object rule with a string member or a string member
JCR: Pass
    trule { "foo" :string| "bar" :string }
JSON: Fail
     { }

#-- Line: 92
#--     tree = JCR.parse( 'trule { "foo":string, "bar":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with one string against an object rule with a string member and a string member
JCR: Pass
    trule { "foo":string, "bar":string }
JSON: Fail
     { "foo":"thing" }

#-- Line: 100
#--     tree = JCR.parse( 'trule { "foo":string | "bar":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string against an object rule with a string member or a string member
JCR: Pass
    trule { "foo":string | "bar":string }
JSON: Pass
     { "foo":"thing" }

#-- Line: 108
#--     tree = JCR.parse( 'trule @(reject) { "foo":string | "bar":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with one string against an reject object rule with a string member or a string member
JCR: Pass
    trule @(reject) { "foo":string | "bar":string }
JSON: Fail
     { "foo":"thing" }

#-- Line: 116
#--     tree = JCR.parse( 'trule { "foo":string, "bar":integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with one string against an object rule with a string member and an integer member
JCR: Pass
    trule { "foo":string, "bar":integer }
JSON: Fail
     { "foo":"thing" }

#-- Line: 124
#--     tree = JCR.parse( 'trule { "foo":string, "bar":integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing", "bar"=>2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with string and integer against an object rule with a string member and an integer member
JCR: Pass
    trule { "foo":string, "bar":integer }
JSON: Pass
     { "foo":"thing", "bar":2 }

#-- Line: 132
#--     tree = JCR.parse( 'trule { "foo":string | "bar":integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "foo"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string against an object rule with a string member or a integer member
JCR: Pass
    trule { "foo":string | "bar":integer }
JSON: Pass
     { "foo":"thing" }

#-- Line: 140
#--     tree = JCR.parse( 'trule { "bar":string, ( "foo":integer | "foo":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], { "bar"=>"thing", "foo"=>2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with string and integer against an object rule with a string member and an integer member or string member
JCR: Pass
    trule { "bar":string, ( "foo":integer | "foo":string ) }
JSON: Pass
     { "bar":"thing", "foo":2 }

#-- Line: 148
#--     tree = JCR.parse( 'trule { "bar":string, ( "foo":integer | "foo":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"bar"=>"thing","foo"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with string and string against an object rule with a string member and an integer member or string member
JCR: Pass
    trule { "bar":string, ( "foo":integer | "foo":string ) }
JSON: Pass
     {"bar":"thing","foo":"thing2" }

#-- Line: 156
#--     tree = JCR.parse( 'trule { 2*2 /m.*/ :string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=>"thing","m2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings against an object rule with string twice
JCR: Pass
    trule { 2*2 /m.*/ :string }
JSON: Pass
     {"m1":"thing","m2":"thing2" }

#-- Line: 164
#--     tree = JCR.parse( 'trule { 1*2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=>"thing","m2"=>"thing2"}, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings against an object rule with string member once or twice
JCR: Pass
    trule { 1*2 /m.*/:string }
JSON: Pass
     {"m1":"thing","m2":"thing2"}

#-- Line: 172
#--     tree = JCR.parse( 'trule { 1*3 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=>"thing","m2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings against an object rule with string member once or twice or thrice
JCR: Pass
    trule { 1*3 /m.*/:string }
JSON: Pass
     {"m1":"thing","m2":"thing2" }

#-- Line: 180
#--     tree = JCR.parse( 'trule { 1*2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=>"thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string against an object rule with string member once or twice
JCR: Pass
    trule { 1*2 /m.*/:string }
JSON: Pass
     {"m1":"thing" }

#-- Line: 188
#--     tree = JCR.parse( 'trule { *2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string against an object rule with string member default or twice
JCR: Pass
    trule { *2 /m.*/:string }
JSON: Pass
     {"m1": "thing" }

#-- Line: 196
#--     tree = JCR.parse( 'trule { *2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {}, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an empty object  against an object rule with string member default or twice
JCR: Pass
    trule { *2 /m.*/:string }
JSON: Pass
     {}

#-- Line: 204
#--     tree = JCR.parse( 'trule { 1* /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string against an object rule with string member once or default
JCR: Pass
    trule { 1* /m.*/:string }
JSON: Pass
     {"m1": "thing" }

#-- Line: 212
#--     tree = JCR.parse( 'trule { 1* /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing", "m2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings against an object rule with string member once or default
JCR: Pass
    trule { 1* /m.*/:string }
JSON: Pass
     {"m1": "thing", "m2":"thing2" }

#-- Line: 220
#--     tree = JCR.parse( 'trule { + /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing", "m2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings against an object rule with string member one or more
JCR: Pass
    trule { + /m.*/:string }
JSON: Pass
     {"m1": "thing", "m2":"thing2" }

#-- Line: 228
#--     tree = JCR.parse( 'trule { 1*2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing","m2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with a string and integer against an object rule with string member once or twice (ignore extras)
JCR: Pass
    trule { 1*2 /m.*/:string }
JSON: Pass
     {"m1": "thing","m2": 2 }

#-- Line: 236
#--     tree = JCR.parse( 'trule { *2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing", "m2"=>2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with a string and integer against an object rule with string member default or twice (ignore extras)
JCR: Pass
    trule { *2 /m.*/:string }
JSON: Pass
     {"m1": "thing", "m2":2 }

#-- Line: 244
#--     tree = JCR.parse( 'trule { "foo":string, "bar":integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"foo"=>"thing","bar"=>2,"foo2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with a string and integer and string against an object rule with string and integer (ignore extra)
JCR: Pass
    trule { "foo":string, "bar":integer }
JSON: Pass
     {"foo":"thing","bar":2,"foo2":"thing2" }

#-- Line: 252
#--     tree = JCR.parse( 'trule { 2*2 /m.*/:string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"m1"=> "thing" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with a string against an object rule with string twice
JCR: Pass
    trule { 2*2 /m.*/:string }
JSON: Fail
     {"m1": "thing" }

#-- Line: 260
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing", "i1"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with a string and integer against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Pass
     {"s1": "thing", "i1": 2 }

#-- Line: 268
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","i1"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings and integer against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","i1": 2 }

#-- Line: 276
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","i1"=> 1,"i2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one string and two integer against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Pass
     {"s1": "thing","i1": 1,"i2": 2 }

#-- Line: 284
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","i1"=> 1,"i2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two string and two integer against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","i1": 1,"i2": 2 }

#-- Line: 292
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","i1"=> 1,"i2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings and two integers against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","i1": 1,"i2": 2 }

#-- Line: 300
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","i1"=> 1,"i2"=> 2,"i3"=> 3 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with one string and three integer against an object rule with string 1*2 and integer 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /i.*/:integer }
JSON: Fail
     {"s1": "thing","i1": 1,"i2": 2,"i3": 3 }

#-- Line: 308
#--     tree = JCR.parse( 'trule { 1*2 /s.*/:string, 1*2 /.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","1"=> 1,"2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings and two integers against an object rule with string 1*2 and any 1*2
JCR: Pass
    trule { 1*2 /s.*/:string, 1*2 /.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","1": 1,"2": 2 }

#-- Line: 316
#--     tree = JCR.parse( 'trule { 2 /s.*/:string, 2 /.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","1"=> 1,"2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings and two integers against an object rule with string 2 and any 2
JCR: Pass
    trule { 2 /s.*/:string, 2 /.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","1": 1,"2": 2 }

#-- Line: 324
#--     tree = JCR.parse( 'trule { + /s.*/:string, + /.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","1"=> 1,"2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with two strings and two integers against an object rule with string + and any +
JCR: Pass
    trule { + /s.*/:string, + /.*/:integer }
JSON: Pass
     {"s1": "thing","s2": "thing2","1": 1,"2": 2 }

#-- Line: 332
#--     tree = JCR.parse( 'trule { ? /s.*/:string, ? /.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=> "thing2","1"=> 1,"2"=> 2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with two strings and two integers against an object rule with string ? and any ?
JCR: Pass
    trule { ? /s.*/:string, ? /.*/:integer }
JSON: Fail
     {"s1": "thing","s2": "thing2","1": 1,"2": 2 }

#-- Line: 340
#--     tree = JCR.parse( 'trule { ? /s.*/:string, ? /.*/:integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","1"=> 1 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an object with one strings and one integers against an object rule with string ? and any ?
JCR: Pass
    trule { ? /s.*/:string, ? /.*/:integer }
JSON: Pass
     {"s1": "thing","1": 1 }

#-- Line: 348
#--     tree = JCR.parse( 'trule { 2 /.*/:any, 1 /.*/:any }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","1"=> 1 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an object with two members against an object rule with overlapping rules
JCR: Pass
    trule { 2 /.*/:any, 1 /.*/:any }
JSON: Fail
     {"s1": "thing","1": 1 }

#-- Line: 356
#--     tree = JCR.parse( 'trule { 2 /s.*/:string, 1 "foo":integer }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2","foo"=>2,"bar"=>"baz" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should ignore extra members in an object
JCR: Pass
    trule { 2 /s.*/:string, 1 "foo":integer }
JSON: Pass
     {"s1": "thing","s2":"thing2","foo":2,"bar":"baz" }

#-- Line: 364
#--     tree = JCR.parse( 'trule { 2 /s.*/:string, 1 "foo":integer, + @(reject) /.*/:any }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2","foo"=>2,"bar"=>"baz" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should not ignore extra members in an object
JCR: Pass
    trule { 2 /s.*/:string, 1 "foo":integer, + @(reject) /.*/:any }
JSON: Fail
     {"s1": "thing","s2":"thing2","foo":2,"bar":"baz" }

#-- Line: 372
#--     tree = JCR.parse( 'trule { 2 /s.*/:string, 1 "foo":integer, ? @(reject) /.*/:any }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2","foo"=>2 }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with not extra members using reject
JCR: Pass
    trule { 2 /s.*/:string, 1 "foo":integer, ? @(reject) /.*/:any }
JSON: Pass
     {"s1": "thing","s2":"thing2","foo":2 }

#-- Line: 380
#--     tree = JCR.parse( 'trule { "s1":string, "o1"{ "ss1":string } }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","o1"=>{"ss1"=>"thing2"} }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with string member and object member
JCR: Pass
    trule { "s1":string, "o1"{ "ss1":string } }
JSON: Pass
     {"s1": "thing","o1":{"ss1":"thing2"} }

#-- Line: 388
#--     tree = JCR.parse( 'trule { "s1":string, ( "s2":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with a string member and group member containing a string member
JCR: Pass
    trule { "s1":string, ( "s2":string ) }
JSON: Pass
     {"s1": "thing","s2":"thing2" }

#-- Line: 396
#--     tree = JCR.parse( 'trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with 2 ORed groups of ANDs 1
JCR: Pass
    trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }
JSON: Pass
     {"s1": "thing","s2":"thing2" }

#-- Line: 404
#--     tree = JCR.parse( 'trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s3"=> "thing","s4"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with 2 ORed groups of ANDs 2
JCR: Pass
    trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }
JSON: Pass
     {"s3": "thing","s4":"thing2" }

#-- Line: 412
#--     tree = JCR.parse( 'trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s5"=> "thing","s6"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail object with 2 ORed groups of ANDs 2
JCR: Pass
    trule { ("s1":string, "s2":string ) | ( "s3":string , "s4":string ) }
JSON: Fail
     {"s5": "thing","s6":"thing2" }

#-- Line: 420
#--     tree = JCR.parse( 'trule { ( ("s1":string, "s2":string ) ) }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=> "thing","s2"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with simple nested groups
JCR: Pass
    trule { ( ("s1":string, "s2":string ) ) }
JSON: Pass
     {"s1": "thing","s2":"thing2" }

#-- Line: 428
#--     tree = JCR.parse( 'trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=>"foo", "s2"=> "thing","s4"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with complex nested groups 1
JCR: Pass
    trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }
JSON: Pass
     {"s1":"foo", "s2": "thing","s4":"thing2" }

#-- Line: 436
#--     tree = JCR.parse( 'trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s3"=>"fuzz", "s4"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with complex nested groups 2
JCR: Pass
    trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }
JSON: Pass
     {"s3":"fuzz", "s4":"thing2" }

#-- Line: 444
#--     tree = JCR.parse( 'trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s0"=>"fizz", "s4"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail object with complex nested groups 1
JCR: Pass
    trule { ( ( "s1":string, "s2":string ) | ( "s3":string ) ) , "s4":string }
JSON: Fail
     {"s0":"fizz", "s4":"thing2" }

#-- Line: 452
#--     tree = JCR.parse( 'orule { ( trule | ( "s3":string ) ) , "s4":string } ;; trule ( "s1":string, "s2":string )' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"s1"=>"foo", "s2"=> "thing","s4"=>"thing2" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with complex nested groups with a named rule 1
JCR: Pass
    orule { ( trule | ( "s3":string ) ) , "s4":string } ;; trule ( "s1":string, "s2":string )
JSON: Pass
     {"s1":"foo", "s2": "thing","s4":"thing2" }

#-- Line: 460
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, c ) | ( b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a", "b"=> "b" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups of overlapping member rules 1
JCR: Pass
    orule { ( a, b ) | ( a, c ) | ( b, c ) }
JSON: Pass
     {"a":"a", "b": "b" }

#-- Line: 469
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, c ) | ( b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a", "c"=> "c" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups of overlapping member rules 2
JCR: Pass
    orule { ( a, b ) | ( a, c ) | ( b, c ) }
JSON: Pass
     {"a":"a", "c": "c" }

#-- Line: 478
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, c ) | ( b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"b"=>"b", "c"=> "c" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups of overlapping member rules 3
JCR: Pass
    orule { ( a, b ) | ( a, c ) | ( b, c ) }
JSON: Pass
     {"b":"b", "c": "c" }

#-- Line: 487
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, c ) | ( b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"b"=>"b", "d"=> "d" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail object with ORed groups of overlapping member rules 3
JCR: Pass
    orule { ( a, b ) | ( a, c ) | ( b, c ) }
JSON: Fail
     {"b":"b", "d": "d" }

#-- Line: 496
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, ?b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a", "b"=> "b" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups with manditory member but optional if another exists 1
JCR: Pass
    orule { ( a, b ) | ( a, ?b, c ) }
JSON: Pass
     {"a":"a", "b": "b" }

#-- Line: 505
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, ?b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail object with ORed groups with manditory member but optional if another exists 1
JCR: Pass
    orule { ( a, b ) | ( a, ?b, c ) }
JSON: Fail
     {"a":"a" }

#-- Line: 514
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, ?b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a", "c"=> "c" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups with manditory member but optional if another exists 2
JCR: Pass
    orule { ( a, b ) | ( a, ?b, c ) }
JSON: Pass
     {"a":"a", "c": "c" }

#-- Line: 523
#--     tree = JCR.parse( 'orule { ( a, b ) | ( a, ?b, c ) }'\
#--                       'a "a":string b "b":string c "c":string')
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], {"a"=>"a", "b"=>"b", "c"=> "c" }, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass object with ORed groups with manditory member but optional if another exists 3
JCR: Pass
    orule { ( a, b ) | ( a, ?b, c ) }
JSON: Pass
     {"a":"a", "b":"b", "c": "c" }

