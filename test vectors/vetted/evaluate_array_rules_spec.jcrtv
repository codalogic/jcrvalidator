#-- Copyright (C) 2016 American Registry for Internet Numbers (ARIN)
#--
#-- Permission to use, copy, modify, and/or distribute this software for any
#-- purpose with or without fee is hereby granted, provided that the above
#-- copyright notice and this permission notice appear in all copies.
#--
#-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
#-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
#-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
#-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
#-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
#-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
#-- IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#-- Line: 20
#--     tree = JCR.parse( 'trule [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], 2, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail something that is not an array
JCR: Pass
    trule [ ]
JSON: Fail
     { }

#-- Line: 28
#--     tree = JCR.parse( 'trule @(reject) [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], 2, JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass something that is not an array with reject
JCR: Pass
    trule @(reject) [ ]
JSON: Pass
     { }

#-- Line: 36
#--     tree = JCR.parse( 'trule [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an empty array against an empty array rule
JCR: Pass
    trule [ ]
JSON: Pass
     []

#-- Line: 44
#--     tree = JCR.parse( 'trule @(reject) [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty reject array against an empty array rule
JCR: Pass
    trule @(reject) [ ]
JSON: Fail
     []

#-- Line: 52
#--     tree = JCR.parse( 'trule [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail a non-empty array against an empty array rule
JCR: Pass
    trule [ ]
JSON: Fail
     [ "thing" ]

#-- Line: 60
#--     tree = JCR.parse( 'trule @(reject) [ ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass a non-empty array against an empty reject array rule
JCR: Pass
    trule @(reject) [ ]
JSON: Pass
     [ "thing" ]

#-- Line: 68
#--     tree = JCR.parse( 'trule [ :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty array against an array rule with a string
JCR: Pass
    trule [ :string ]
JSON: Fail
     [ ]

#-- Line: 76
#--     tree = JCR.parse( 'trule [ :string, :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty array against an array rule with a string and a string
JCR: Pass
    trule [ :string, :string ]
JSON: Fail
     [ ]

#-- Line: 84
#--     tree = JCR.parse( 'trule [ :string| :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an empty array against an array rule with a string or a string
JCR: Pass
    trule [ :string| :string ]
JSON: Fail
     [ ]

#-- Line: 92
#--     tree = JCR.parse( 'trule [ :string, :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with one string against an array rule with a string and a string
JCR: Pass
    trule [ :string, :string ]
JSON: Fail
     [ "thing" ]

#-- Line: 100
#--     tree = JCR.parse( 'trule [ :string | :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string against an array rule with a string or a string
JCR: Pass
    trule [ :string | :string ]
JSON: Pass
     [ "thing" ]

#-- Line: 108
#--     tree = JCR.parse( 'trule @(reject) [ :string | :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with one string against an reject array rule with a string or a string
JCR: Pass
    trule @(reject) [ :string | :string ]
JSON: Fail
     [ "thing" ]

#-- Line: 116
#--     tree = JCR.parse( 'trule [ :string, :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with one string against an array rule with a string and an integer
JCR: Pass
    trule [ :string, :integer ]
JSON: Fail
     [ "thing" ]

#-- Line: 124
#--     tree = JCR.parse( 'trule [ :string, :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with string and integer against an array rule with a string and an integer
JCR: Pass
    trule [ :string, :integer ]
JSON: Pass
     [ "thing", 2 ]

#-- Line: 132
#--     tree = JCR.parse( 'trule [ :string | :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string against an array rule with a string or a integer
JCR: Pass
    trule [ :string | :integer ]
JSON: Pass
     [ "thing" ]

#-- Line: 140
#--     tree = JCR.parse( 'trule [ :string, ( :integer | :string ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with string and integer against an array rule with a string and an integer or string
JCR: Pass
    trule [ :string, ( :integer | :string ) ]
JSON: Pass
     [ "thing", 2 ]

#-- Line: 148
#--     tree = JCR.parse( 'trule [ :string, ( :integer | :string ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with string and string against an array rule with a string and an integer or string
JCR: Pass
    trule [ :string, ( :integer | :string ) ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 156
#--     tree = JCR.parse( 'trule [ 2*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings against an array rule with string twice
JCR: Pass
    trule [ 2*2 :string ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 164
#--     tree = JCR.parse( 'trule [ 1*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings against an array rule with string once or twice
JCR: Pass
    trule [ 1*2 :string ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 172
#--     tree = JCR.parse( 'trule [ 1*3 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings against an array rule with string once or twice or thrice
JCR: Pass
    trule [ 1*3 :string ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 180
#--     tree = JCR.parse( 'trule [ 1*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string against an array rule with string once or twice
JCR: Pass
    trule [ 1*2 :string ]
JSON: Pass
     [ "thing" ]

#-- Line: 188
#--     tree = JCR.parse( 'trule [ *2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string against an array rule with string default or twice
JCR: Pass
    trule [ *2 :string ]
JSON: Pass
     [ "thing" ]

#-- Line: 196
#--     tree = JCR.parse( 'trule [ *2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an empty array against an array rule with string default or twice
JCR: Pass
    trule [ *2 :string ]
JSON: Pass
     [ ]

#-- Line: 204
#--     tree = JCR.parse( 'trule [ 1* :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string against an array rule with string once or default
JCR: Pass
    trule [ 1* :string ]
JSON: Pass
     [ "thing" ]

#-- Line: 212
#--     tree = JCR.parse( 'trule [ 1* :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings against an array rule with string once or default
JCR: Pass
    trule [ 1* :string ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 220
#--     tree = JCR.parse( 'trule [ + :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings against an array rule with string +
JCR: Pass
    trule [ + :string ]
JSON: Pass
     [ "thing", "thing2" ]

#-- Line: 228
#--     tree = JCR.parse( 'trule [ 1*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with a string and integer against an array rule with string once or twice
JCR: Pass
    trule [ 1*2 :string ]
JSON: Fail
     [ "thing", 2 ]

#-- Line: 236
#--     tree = JCR.parse( 'trule [ 1*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing1", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with three strings against an array rule with string once or twice
JCR: Pass
    trule [ 1*2 :string ]
JSON: Fail
     [ "thing", "thing1", "thing2" ]

#-- Line: 244
#--     tree = JCR.parse( 'trule [ 0*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing1", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with three strings against an array rule with string zero or twice
JCR: Pass
    trule [ 0*2 :string ]
JSON: Fail
     [ "thing", "thing1", "thing2" ]

#-- Line: 252
#--     tree = JCR.parse( 'trule [ 0*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing1", "thing2", "thing3", "thing4" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with five strings against an array rule with string zero or twice
JCR: Pass
    trule [ 0*2 :string ]
JSON: Fail
     [ "thing", "thing1", "thing2", "thing3", "thing4" ]

#-- Line: 260
#--     tree = JCR.parse( 'trule [ 2*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing1", "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with three strings against an array rule with string twice
JCR: Pass
    trule [ 2*2 :string ]
JSON: Fail
     [ "thing", "thing1", "thing2" ]

#-- Line: 268
#--     tree = JCR.parse( 'trule [ 2*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing1", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with two strings and integer against an array rule with string twice
JCR: Pass
    trule [ 2*2 :string ]
JSON: Fail
     [ "thing", "thing1", 2 ]

#-- Line: 276
#--     tree = JCR.parse( 'trule [ *2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with a string and integer against an array rule with string default or twice
JCR: Pass
    trule [ *2 :string ]
JSON: Fail
     [ "thing", 2 ]

#-- Line: 284
#--     tree = JCR.parse( 'trule [ :string, :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2, "thing2" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with a string and integer and string against an array rule with string and integer
JCR: Pass
    trule [ :string, :integer ]
JSON: Fail
     [ "thing", 2, "thing2" ]

#-- Line: 292
#--     tree = JCR.parse( 'trule [ 2*2 :string ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with a string against an array rule with string twice
JCR: Pass
    trule [ 2*2 :string ]
JSON: Fail
     [ "thing" ]

#-- Line: 300
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with a string and integer against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Pass
     [ "thing", 2 ]

#-- Line: 308
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and integer against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Pass
     [ "thing", "thing2", 2 ]

#-- Line: 316
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string and two integer against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Pass
     [ "thing", 1, 2 ]

#-- Line: 324
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two string and two integer against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Pass
     [ "thing", "thing2", 1, 2 ]

#-- Line: 332
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two integers against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Pass
     [ "thing", "thing2", 1, 2 ]

#-- Line: 340
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with one string and three integer against an array rule with string 1*2 and integer 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :integer ]
JSON: Fail
     [ "thing", 1, 2, 3 ]

#-- Line: 348
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two integers against an array rule with string 1*2 and any 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :any ]
JSON: Pass
     [ "thing", "thing2", 1, 2 ]

#-- Line: 356
#--     tree = JCR.parse( 'trule [ * :string, * :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two integers against an array rule with string * and any *
JCR: Pass
    trule [ * :string, * :any ]
JSON: Pass
     [ "thing", "thing2", 1, 2 ]

#-- Line: 364
#--     tree = JCR.parse( 'trule [ 1*2 :string, 1*2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an array rule with string 1*2 and any 1*2
JCR: Pass
    trule [ 1*2 :string, 1*2 :any ]
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 372
#--     tree = JCR.parse( 'trule [ 2 :string, 2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an array rule with string 2 and any 2
JCR: Pass
    trule [ 2 :string, 2 :any ]
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 380
#--     tree = JCR.parse( 'trule [ 2 :string, 2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", [ 1, 2 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with one string and one arrays against an array rule with string 2 and any 2
JCR: Pass
    trule [ 2 :string, 2 :any ]
JSON: Fail
     [ "thing", [ 1, 2 ] ]

#-- Line: 388
#--     tree = JCR.parse( 'trule @(reject) [ 2 :string, 2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", [ 1, 2 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with one string and one arrays against an reject array rule with string 2 and any 2
JCR: Pass
    trule @(reject) [ 2 :string, 2 :any ]
JSON: Pass
     [ "thing", [ 1, 2 ] ]

#-- Line: 396
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, 2 :any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an unordered array rule with string 2 and any 2
JCR: Pass
    trule @(unordered) [ 2 :string, 2 :any ]
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 404
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, (:any,:any) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an unordered array rule with string 2 and group any
JCR: Pass
    trule @(unordered) [ 2 :string, (:any,:any) ]
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 412
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, grule ] ;; grule (:any,:any)' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an unordered array rule with string 2 and named group any
JCR: Pass
    trule @(unordered) [ 2 :string, grule ] ;; grule (:any,:any)
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 420
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, 2 grule ] ;; grule (:any)' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two arrays against an unordered array rule with string 2 and 2 named group any
JCR: Pass
    trule @(unordered) [ 2 :string, 2 grule ] ;; grule (:any)
JSON: Pass
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ] ]

#-- Line: 428
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, 2 grule ] ;; grule (:any)' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ], [ 4, 5 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with two strings and three arrays against an unordered array rule with string 2 and 2 named group any
JCR: Pass
    trule @(unordered) [ 2 :string, 2 grule ] ;; grule (:any)
JSON: Fail
     [ "thing", "thing2", [ 1, 2 ], [ 2, 3 ], [ 4, 5 ] ]

#-- Line: 436
#--     tree = JCR.parse( 'trule @(unordered) [ 2 :string, 2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, "thing", "thing2"  ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass an array with two strings and two integers against an unordered array rule with string 2 and any 2
JCR: Pass
    trule @(unordered) [ 2 :string, 2 :integer ]
JSON: Pass
     [ 1, 2, "thing", "thing2"  ]

#-- Line: 444
#--     tree = JCR.parse( 'trule @(reject) @(unordered) [ 2 :string, 2 :integer ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, "thing", "thing2"  ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail an array with two strings and two arrays against an reject, unordered array rule with string 2 and any 2
JCR: Pass
    trule @(reject) @(unordered) [ 2 :string, 2 :integer ]
JSON: Fail
     [ 1, 2, "thing", "thing2"  ]

#-- Line: 452
#--     tree = JCR.parse( 'trule [ 2 :string, 2 :integer, *:any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, "thing", "thing2", 23.0, 99.2  ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail even with extra elements in an array
JCR: Pass
    trule [ 2 :string, 2 :integer, *:any ]
JSON: Fail
     [ 1, 2, "thing", "thing2", 23.0, 99.2  ]

#-- Line: 460
#--     tree = JCR.parse( 'trule [ 2 :string, 2 :integer, *:any ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2, 23.0, 99.2  ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass even with extra elements in an array
JCR: Pass
    trule [ 2 :string, 2 :integer, *:any ]
JSON: Pass
     [ "thing", "thing2", 1, 2, 23.0, 99.2  ]

#-- Line: 468
#--     tree = JCR.parse( 'trule [ 2 :string, 2 grule ] ;; grule ( :integer) ' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with 2 string and a group of two integers
JCR: Pass
    trule [ 2 :string, 2 grule ] ;; grule ( :integer) 
JSON: Pass
     [ "thing", "thing2", 1, 2 ]

#-- Line: 476
#--     tree = JCR.parse( 'trule [ 2 :string, 2 grule ] ;; grule ( :integer) ' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail with 2 string and a group of two integers and extra integer
JCR: Pass
    trule [ 2 :string, 2 grule ] ;; grule ( :integer) 
JSON: Fail
     [ "thing", "thing2", 1, 2, 3 ]

#-- Line: 484
#--     tree = JCR.parse( 'trule [ 2 :string, grule ] ;; grule ( :integer, :string ) ' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "thing", "thing2", 1, "thing3" ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with 2 string and a group of integer and string
JCR: Pass
    trule [ 2 :string, grule ] ;; grule ( :integer, :string ) 
JSON: Pass
     [ "thing", "thing2", 1, "thing3" ]

#-- Line: 492
#--     tree = JCR.parse( 'arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "a", [ 1, 2 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with ORed group each with string and repeated integer 1
JCR: Pass
    arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]
JSON: Pass
     [ "a", [ 1, 2 ] ]

#-- Line: 500
#--     tree = JCR.parse( 'arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "a", [ 1, 2, 3, 4 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail with ORed group each with string and repeated integer 1
JCR: Pass
    arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]
JSON: Fail
     [ "a", [ 1, 2, 3, 4 ] ]

#-- Line: 508
#--     tree = JCR.parse( 'arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "b", [ 1, 2, 3, 4 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with ORed group each with string and repeated integer 2
JCR: Pass
    arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]
JSON: Pass
     [ "b", [ 1, 2, 3, 4 ] ]

#-- Line: 516
#--     tree = JCR.parse( 'arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ "b", [ 1, 2 ] ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail with ORed group each with string and repeated integer 2
JCR: Pass
    arule [ ( :"a", [ 2 : integer ] ) | ( :"b", [ 4 : integer ] ) ]
JSON: Fail
     [ "b", [ 1, 2 ] ]

#-- Line: 524
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with three ANDs and an OR 1
JCR: Pass
    arule [ :1, :2, ( :3 | :4 ) ]
JSON: Pass
     [ 1, 2, 3 ]

#-- Line: 532
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with three ANDs and an OR 2
JCR: Pass
    arule [ :1, :2, ( :3 | :4 ) ]
JSON: Pass
     [ 1, 2, 4 ]

#-- Line: 540
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 4 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail with three ANDs and an OR
JCR: Pass
    arule [ :1, :2, ( :3 | :4 ) ]
JSON: Fail
     [ 4 ]

#-- Line: 548
#--     tree = JCR.parse( 'arule [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with three ANDs in a group and an OR 1
JCR: Pass
    arule [ ( :1, :2, :3 ) | :4 ]
JSON: Pass
     [ 1, 2, 3 ]

#-- Line: 556
#--     tree = JCR.parse( 'arule [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 4 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass with three ANDs  in a group and an OR 2
JCR: Pass
    arule [ ( :1, :2, :3 ) | :4 ]
JSON: Pass
     [ 4 ]

#-- Line: 564
#--     tree = JCR.parse( 'arule [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail with three ANDs in a group and an OR
JCR: Pass
    arule [ ( :1, :2, :3 ) | :4 ]
JSON: Fail
     [ 1, 2, 4 ]

#-- Line: 572
#--     tree = JCR.parse( 'arule @(unordered) [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 3, 2, 1 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass unordered with three ANDs in a group and an OR 1
JCR: Pass
    arule @(unordered) [ ( :1, :2, :3 ) | :4 ]
JSON: Pass
     [ 3, 2, 1 ]

#-- Line: 580
#--     tree = JCR.parse( 'arule @(unordered) [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 4 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_truthy
## should pass unordered with three ANDs  in a group and an OR 2
JCR: Pass
    arule @(unordered) [ ( :1, :2, :3 ) | :4 ]
JSON: Pass
     [ 4 ]

#-- Line: 588
#--     tree = JCR.parse( 'arule [ ( :1, :2, :3 ) | :4 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     e = JCR.evaluate_rule( tree[0], tree[0], [ 4, 2, 1 ], JCR::EvalConditions.new( mapping, nil ) )
#--     expect( e.success ).to be_falsey
## should fail unordered with three ANDs in a group and an OR
JCR: Pass
    arule [ ( :1, :2, :3 ) | :4 ]
JSON: Fail
     [ 4, 2, 1 ]

#-- Line: 596
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 ) , :5 ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_falsey
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
## should demonstrate OR and AND logic 1
JCR: Pass
    arule [ :1, :2, ( :3 | :4 ) , :5 ]
JSON: Pass
     [ 1, 2, 4, 5 ]

#-- Line: 605
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 | :5 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_falsey
## should demonstrate OR and AND logic 2
JCR: Pass
    arule [ :1, :2, ( :3 | :4 | :5 ) ]
JSON: Pass
     [ 1, 2, 3 ]
JSON: Pass
     [ 1, 2, 4 ]
JSON: Pass
     [ 1, 2, 5 ]
JSON: Fail
     [ 1, 2, 3, 5 ]

#-- Line: 615
#--     tree = JCR.parse( 'arule [ :1, :2, ( :3 | :4 ), (:5 | :6 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4, 6 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4, 5 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 6 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
## should demonstrate OR and AND logic 3
JCR: Pass
    arule [ :1, :2, ( :3 | :4 ), (:5 | :6 ) ]
JSON: Pass
     [ 1, 2, 3, 6 ]

#-- Line: 625
#--     tree = JCR.parse( 'arule [ :1, :2,( :3 | :4 ), :5, ( :6 | :7 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 5, 6 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 3, 5, 7 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4, 5, 6 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 2, 4, 5, 7 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
## should demonstrate OR and AND logic 4
JCR: Pass
    arule [ :1, :2,( :3 | :4 ), :5, ( :6 | :7 ) ]
JSON: Pass
     [ 1, 2, 4, 5, 7 ]

#-- Line: 635
#--     tree = JCR.parse( 'arule [ ( :1 | :2 ) , ( :3 | :4 ) ]' )
#--     mapping = JCR.map_rule_names( tree )
#--     JCR.check_rule_target_names( tree, mapping )
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 3 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 2, 4 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 1, 4 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
#--     expect( JCR.evaluate_rule( tree[0], tree[0], [ 2, 3 ], JCR::EvalConditions.new( mapping, nil ) ).success ).to be_truthy
## should demonstrate OR and AND logic 5
JCR: Pass
    arule [ ( :1 | :2 ) , ( :3 | :4 ) ]
JSON: Pass
     [ 2, 3 ]

